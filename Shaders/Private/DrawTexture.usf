
#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "QuadVertex.ush"
#include "Utils.ush"

float3 PositionAndRotate;
float4 SizeAndPivot;
float4 NoiseAndZeroPlaneDepth;
float4 EdgeValue;
Texture2D DepthTexture; 
SamplerState DepthSampler;
Texture2D SdfTexture;
SamplerState SdfSampler;


void MainVS(
	in uint GlobalVertexId : SV_VertexID,
	out float2 OutUV : TEXCOORD0,
	out float4 OutPosition : SV_POSITION
	)
{
	OutPosition = float4(GetQuadVertexByIndex(GlobalVertexId),1.0f);
	OutUV = FlipUV(GetQuadUVByIndex(GlobalVertexId));
}

static const int p[512] =
{
	151, 160, 137, 91, 90, 15,
    131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23,
    190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33,
    88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166,
    77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244,
    102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196,
    135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123,
    5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42,
    223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9,
    129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228,
    251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107,
    49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,
    138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180,
 
    151, 160, 137, 91, 90, 15,
    131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23,
    190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33,
    88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166,
    77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244,
    102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196,
    135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123,
    5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42,
    223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9,
    129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228,
    251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107,
    49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,
    138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180
};
 
float FadeValue(float t)
{
	return t * t * t * (t * (t * 6 - 15) + 10);
}
 
float LerpValue(float t, float a, float b)
{
	return a + t * (b - a);
}
 
float GradientDirection(int hash, float x, float y, float z)
{
    // CONVERT LO 4 BITS OF HASH CODE INTO 12 GRADIENT DIRECTIONS.
	int h = hash & 15;
	float u = h < 8 ? x : y;
	float v = h < 4 ? y : h == 12 || h == 14 ? x : z;
	return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v);
}

float PerlinNoise(float3 pos)
{
	// FIND UNIT CUBE THAT CONTAINS POINT.
	int X = (int) floor(pos.x) & 255;
	int Y = (int) floor(pos.y) & 255;
	int Z = (int) floor(pos.z) & 255;
   
	// FIND RELATIVE X,Y,Z OF POINT IN CUBE.
	float x = pos.x - floor(pos.x);
	float y = pos.y - floor(pos.y);
	float z = pos.z - floor(pos.z);
   
	// COMPUTE FADE CURVES FOR EACH OF X,Y,Z.
	float u = FadeValue(x);
	float v = FadeValue(y);
	float w = FadeValue(z);
   
	// HASH COORDINATES OF THE 8 CUBE CORNERS
	int A = p[X] + Y;
	int AA = p[A] + Z;
	int AB = p[A + 1] + Z;
	int B = p[X + 1] + Y;
	int BA = p[B] + Z;
	int BB = p[B + 1] + Z;
 
	// AND ADD BLENDED RESULTS FROM  8 CORNERS OF CUBE
	return clamp(0.97 * LerpValue(w, LerpValue(v, LerpValue(u, GradientDirection(p[AA], x, y, z), // CORNER 0      
		   GradientDirection(p[BA], x - 1, y, z)), // CORNER 1                              
		   LerpValue(u, GradientDirection(p[AB], x, y - 1, z), // CORNER 2                        
		   GradientDirection(p[BB], x - 1, y - 1, z))), // CORNER 3                      
		   LerpValue(v, LerpValue(u, GradientDirection(p[AA + 1], x, y, z - 1), // CORNER 4            
		   GradientDirection(p[BA + 1], x - 1, y, z - 1)), // CORNER 5                  
		   LerpValue(u, GradientDirection(p[AB + 1], x, y - 1, z - 1), // CORNER 6  
		   GradientDirection(p[BB + 1], x - 1, y - 1, z - 1)))), -1.0, 1.0); // CORNER 7
}

void MainPS(
	in float2 UV : TEXCOORD0,
	in float4 Position : SV_POSITION,
	out float4 OutColor : COLOR
	)
{
	float2 BL = FlipUV(GetQuadUVByIndex(0)) - float2(0.5f,0.5f) + SizeAndPivot.zw; // 0,1 - 0.5,0.5  = -0.5 ,0.5
	float2 BR = FlipUV(GetQuadUVByIndex(1)) - float2(0.5f,0.5f) + SizeAndPivot.zw; // 1,1	- 0.5,0.5  = 0.5 ,0.5
	float2 TL = FlipUV(GetQuadUVByIndex(2)) - float2(0.5f,0.5f) + SizeAndPivot.zw; // 0,0 - 0.5,0.5  = -0.5,-0.5
	float2 TR = FlipUV(GetQuadUVByIndex(3)) - float2(0.5f,0.5f) + SizeAndPivot.zw; // 1,0 - 0.5,0.5  = 0.5,-0.5
	const float2x2 ScaleMat = ScaleMatrix(SizeAndPivot.xy);
	const float2x2 RotMat = RotateMatrix(DegreesToRadians(PositionAndRotate.z));
	BL = mul(mul(BL,ScaleMat), RotMat) + PositionAndRotate.xy;
	BR = mul(mul(BR,ScaleMat), RotMat) + PositionAndRotate.xy;
	TL = mul(mul(TL,ScaleMat), RotMat) + PositionAndRotate.xy;
	TR = mul(mul(TR,ScaleMat), RotMat) + PositionAndRotate.xy;

	float b1 = TriangleContainPoint(BL,BR,TL,UV);
	float b2 = TriangleContainPoint(TL,BR,TR,UV);
	if(b1 <= 0.0f && b2 <= 0.0f)
	{
		discard;
	}
	float2 UB = UV - BL;
	float2 TB = TL - BL;
	float angle1 = acos(dot(normalize(UB),normalize(TB)));
	float len = length(UB);
	float2 uv2 = float2(len * sin(angle1),len * cos(angle1)) / SizeAndPivot.xy;
	OutColor.r = Texture2DSample(DepthTexture,DepthSampler, FlipUV(uv2)).r;
	float sdf = Texture2DSample(SdfTexture,SdfSampler, FlipUV(uv2)).r;
	OutColor.g = 0.01f;

	float v = (1.0f - sdf) * EdgeValue.w;
	float f = (1.0f - step(1.0f,v)) * step(0.001f,v) * (1.0f - step(0.001f,OutColor.r));
	
	OutColor.r += (cos(v * EdgeValue.x + EdgeValue.z) * EdgeValue.y  -
	 	PerlinNoise(float3(FlipUV(uv2) * NoiseAndZeroPlaneDepth.x,NoiseAndZeroPlaneDepth.z)) * NoiseAndZeroPlaneDepth.y) * f;
	//OutColor.r += cos(v * EdgeValue.x + EdgeValue.z) * EdgeValue.y  * f;
	OutColor.g += 0.5f * f;
	OutColor.g += 1.0f * (1.0f - step(1.0f,f)) *  step(0.001f,OutColor.r);
}